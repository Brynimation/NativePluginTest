#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
#include "ShaderHelper.hlsl"

//Describes a vertex on a generated mesh. Should be identical to the DrawVertex struct in the Compute Shader
struct DrawVertex
{
	float3 positionWS;
	float2 uv;
};

struct DrawTriangle
{
	float3 normalWS;
	DrawVertex verts[3];
};

//We're using the data from the _DrawTriangles buffer, rather than an Attributes struct
StructuredBuffer<DrawTriangle> _DrawTriangles;

//This structure is generated by the Vertex shader and passed to the fragment shader
struct VertexOutput
{
	float3 positionWS : TEXCOORD0;
	float3 normalWS : TEXCOORD1;
	float2 uv : TEXCOORD2;
	float4 positionHCS : SV_POSITION;
};

TEXTURE2D(_MainTex);
SAMPLER(sampler_MainTex);
float4 _MainTex_ST;

//vertex shader 
VertexOutput vert(uint vertexID : SV_VertexID)
{
	//We need the vertexID as 3 consecutive ids form a triangle 
	VertexOutput o;

	//Since the buffer is structured in triangles, we divide the index by three to get the triangle. To get the vertex on the triangle, we take the remainder
	//of the vertexid / 3 (vertex % 3)
	DrawTriangle tri = _DrawTriangles[vertexID/3];
	DrawVertex input = tri.verts[vertexID % 3];

	o.positionWS = input.positionWS;
	o.normalWS = tri.normalWS;
	o.uv = TRANSFORM_TEX(input.uv, _MainTex);
	o.positionHCS = CalculatePositionHCSWithShadowCasterLogic(input.positionWS, tri.normalWS);

	return o;
}

float4 frag(VertexOutput i) : SV_TARGET0 
{
#ifdef SHADOW_CASTER_PASS
	return 0;
#else
	InputData lightingInput;
	lightingInput.positionWS = i.positionWS;
	lightingInput.normalWS = i.normalWS;
	lightingInput.viewDirectionWS = GetViewDirectionFromPosition(lightingInput.positionWS);
	lightingInput.shadowCoord = CalculateShadowCoord(lightingInput.positionWS, i.positionHCS);
	lightingInput.fogCoord = 0;
	lightingInput.vertexLighting = half3(0,0,0);
	lightingInput.bakedGI = float3(0,0,0);
	lightingInput.normalizedScreenSpaceUV = float2(0,0);
	lightingInput.shadowMask = half4(0,0,0,0);


	float3 albedo = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv).rgb;

	SurfaceData surfaceData;
	surfaceData.albedo = albedo;
	surfaceData.specular = 1;
	surfaceData.metallic = 0;
	surfaceData.smoothness = 0;
	surfaceData.normalTS = lightingInput.normalWS;
	surfaceData.emission = 0;
	surfaceData.occlusion = 0;
	surfaceData.alpha = 1;

	//This is the URP simple lighting function. The arguments are lightingInput, albedo colour, specular colour, smoothness, emission colour and alpha
	return UniversalFragmentBlinnPhong(lightingInput,surfaceData);
#endif
}

/*struct InputData {
    float3  positionWS;
    half3   normalWS;
    half3   viewDirectionWS;
    float4  shadowCoord;
    half    fogCoord;
    half3   vertexLighting;
    half3   bakedGI;
    float2  normalizedScreenSpaceUV;
    half4   shadowMask;
};

struct SurfaceData {
    half3 albedo;
    half3 specular;
    half  metallic;
    half  smoothness;
    half3 normalTS;
    half3 emission;
    half  occlusion;
    half  alpha;
	
	// And added in v10 :
    half  clearCoatMask;
    half  clearCoatSmoothness;
};

*/